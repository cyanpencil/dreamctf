#! /bin/python3
import hashlib, secrets, sys

# We're working with a blockcipher roughly inspired by AES
# The state is a 4x4 matrix of individual bytes
#  and in each of 10 rounds, we will transform that state with a round key

def into(bts):
    """Transform the lenth 16 bytestring bts into a 4x4 matrix as state representation
    the bytestring (a0, a1, ..., a15) is transformed to the matrix
        a0  a1  a2  a3
        a4  a5  a6  a7
        a8  a9  a10 a11
        a12 a13 a14 a15
        """
    state = []
    for i in range(4):
        state.append(list(bts[4*i:4*(i + 1)]))
    return state

def outof(mat):
    """Transform a 4x4 state matrix back into a bytestring by concatenating everything"""
    res = b""
    for row in mat:
        res += bytes(row)
    return res

def addkey(state, key):
    """Add (xor) two 4x4 matrices together."""
    res = []
    for i in range(4):
        row = []
        for j in range(4):
            row.append(state[i][j] ^ key[i][j])
        res.append(row)
    return res

def shiftrows(state):
    """Rotate each row by it's index, transforming the state as follows (starting from the state as shown for `into`)
        a0  a1  a2  a3
        a5  a6  a7  a4
        a10 a11 a8  a9 
        a15 a12 a13 a14
    """
    res = []
    for i, row in enumerate(state):
        res.append(row[i:] + row[:i])
    return res

def blocks(b):
    """Split the bytestring b into blocks of length 16"""
    assert len(b) % 16 == 0
    res = []
    while b != b"":
        res.append(b[:16])
        b = b[16:]
    return res

def xor(a, b):
    """xor two bytestrings of equal length together, byte per byte"""
    res = []
    for i in range(len(a)):
        res.append(a[i] ^ b[i])
    return bytes(res)

def keys(k):
    """We take a key `k` and expand it into 10 independent 'subkeys', so we can use one per round
    This is definitely not the AES key schedule, but I was lazy and it works"""
    for i in range(10):
        yield hashlib.sha256(k + k[i:i+1]).digest()[:16]

def pad(x):
    """Pad a bytestring to next *next* multiple of 16 bytes long
    We need this because our block cipher needs blocks of exactly 16 bytes"""
    n = 16 - (len(x) % 16)
    return x + bytes([n] * n)

def encrypt(k, b):
    """The actual block cipher:
        - Our initial state will be `key xor block`
        - For each of 10 rounds:
            + we apply the 'shiftrows' operation
            + we add (xor) the next subkey as generated by `keys` into the state
        - We bring back the state as bytes, this is the encryption of this block"""
    s = addkey(into(k), into(b))
    for k in keys(k):
        s = addkey(into(k), shiftrows(s))
    return outof(s)

def cbc(k, m, f):
    """Apply the cipher block chaining mode of operation.
    See https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC) for an overview of how this works exactly"""
    iv = secrets.token_bytes(16)
    res = iv
    for b in blocks(pad(m)):
        iv = f(k, xor(b, iv))
        res += iv
    return res

def pr(*args, **kw):
    """Just a wrapper around print, making sure we flush stdout so you can see the result"""
    print(*args, **kw)
    sys.stdout.flush()

if __name__ == "__main__":
    pr("Welcome.")
    with open("flag.txt", "rb") as f:
        flag = f.read()

    # Sample a key for this session, it'll be used for the entire session, but only for this session
    key = secrets.token_bytes(16)

    # Output an encryption of the flag
    pr(cbc(key, flag, encrypt).hex())

    # We accept a series of messages, and respond with an encryption under our session key for each
    for _ in range(20):
        q = bytes.fromhex(input())
        assert len(q) < 200
        pr(cbc(key, q, encrypt).hex())
